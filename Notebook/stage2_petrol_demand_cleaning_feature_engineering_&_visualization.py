# -*- coding: utf-8 -*-
"""stage2: petrol_demand_cleaning - Feature Engineering & Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19VqsqIap9DINS9X0A8K5mRuxR-OByRCJ

**Stage 2: Feature Engineering & Visualization**

This Colab notebook performs feature engineering of petrol demand data:

* Keeps all columns (11 columns)

* Generates time-based features

* Adds lags and rolling features

* Performs ADF test for stationarity

* Performs seasonal decomposition

* Plots ACF/PACF

* Saves processed CSV for modeling
"""

# Install required packages (if not already installed)
!pip install statsmodels matplotlib pandas

# Import libraries
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from google.colab import files

# Upload your CSV file
uploaded = files.upload()  # Upload cleaned_petrol_demand.csv

# Load uploaded CSV
import io
file_name = list(uploaded.keys())[0]
df = pd.read_csv(io.BytesIO(uploaded[file_name]))
df.columns = df.columns.str.strip()  # Remove whitespace
df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
df = df.set_index('Date')
df.head()

# Time-based features
df['Year'] = df.index.year
df['Month'] = df.index.month
df['DayOfWeek'] = df.index.dayofweek
df['IsWeekend'] = df['DayOfWeek'].isin([5,6]).astype(int)
df['Quarter'] = df.index.quarter
df.head(20)

# Lag and rolling features
lags = [1, 7, 14, 30]
for lag in lags:
    df[f'lag_{lag}'] = df['Order_Demand'].shift(lag)

df['rolling_7'] = df['Order_Demand'].rolling(7).mean()
df['rolling_30'] = df['Order_Demand'].rolling(30).mean()
df['ewm_7'] = df['Order_Demand'].ewm(span=7).mean()
df.head()

"""This block creates lag and rolling features to capture past trends in the Order_Demand series.

The shift function generates lag features (lag_1, lag_7, lag_14, lag_30) that store demand values from previous 1, 7, 14, and 30 days, helping the model understand past patterns.

The rolling functions compute 7-day and 30-day moving averages, smoothing short-term fluctuations and highlighting trends.

The ewm function calculates an exponentially weighted moving average over 7 days, giving more weight to recent observations for capturing recent trends more effectively.

These features are widely used in time series forecasting models to improve prediction accuracy.
"""

# ADF Test
series = df['Order_Demand']
adf_result = adfuller(series.dropna())
print('ADF Statistic:', adf_result[0])
print('p-value:', adf_result[1])
if adf_result[1] > 0.05:
    print("Series is non-stationary. Differencing may be needed.")

"""This block of code performs a stationarity test on the Order_Demand time series using the Augmented Dickey-Fuller (ADF) test, which is a standard statistical test in time series analysis. First, it selects the Order_Demand column as the series to analyze and removes any missing values. The adfuller function then calculates the ADF statistic and the corresponding p-value, which indicate whether the series has a unit root (i.e., is non-stationary) or not. Finally, it prints these values and interprets the result: if the p-value is greater than 0.05, the series is considered non-stationary, suggesting that transformations such as differencing may be required to make the series stationary before applying forecasting models like ARIMA or SARIMA. This step is crucial because most time series models assume the input data is stationary for accurate predictions."""

# Seasonal decomposition
period = 365 if len(series) > 2*365 else 30
res = seasonal_decompose(series.dropna(), model='additive', period=period)
res.plot(); plt.show()

"""This code performs seasonal decomposition on the Order_Demand series, splitting it into trend, seasonal, and residual components to better understand underlying patterns. It automatically chooses a period of 365 days for long datasets or 30 days for shorter ones and visualizes the decomposition using plots."""

# ACF and PACF plots
plot_acf(series.dropna(), lags=40)
plt.show()

plot_pacf(series.dropna(), lags=40, method='yw')
plt.show()

"""This code generates ACF (Autocorrelation Function) and PACF (Partial Autocorrelation Function) plots for the Order_Demand series, which show how current values are correlated with past values at different lags. These plots help identify patterns and decide appropriate lag parameters (p and q) when building time series models like ARIMA or SARIMA."""

# Save processed CSV and provide download link
df.to_csv('petrol_features_stage2.csv', index=True)
files.download('petrol_features_stage2.csv')