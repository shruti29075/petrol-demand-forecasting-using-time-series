# -*- coding: utf-8 -*-
"""Stage3:Petrol Demand Forecasting using SARIMA/SARIMAX & LSTM with KPI Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10kFH3yDrrMeR9McpcOIB1-o71nPXeCf1
"""

# 1. Import Libraries
# --------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# 2. Load FEATURE ENGINEERED Data FROM STAGE 2
# --------------------------
df = pd.read_csv('/content/petrol_features_stage2.csv')
df.head()

"""**MODEL BUILDING:**
**MODEL 1:**

**SARIMAX **(Seasonal AutoRegressive Integrated Moving Average with eXogenous variables):

SARIMAX extends ARIMA by handling seasonality and allowing external variables (exogenous inputs).

It combines autoregression (AR), differencing (I), and moving average (MA) components.

Ideal for time series forecasting with repeating seasonal patterns and influencing factors.

Provides interpretable parameters and works well for small to medium-sized datasets.
"""

# 3. SARIMA/SARIMAX Forecast

# --------------------------
# SARIMA Example (seasonal order: weekly seasonality assumed)
sarima_order = (1,1,1)       # p,d,q
seasonal_order = (1,1,1,7)   # P,D,Q,s (weekly seasonality)
sarima_model = SARIMAX(df['Order_Demand'],
                       order=sarima_order,
                       seasonal_order=seasonal_order,
                       enforce_stationarity=False,
                       enforce_invertibility=False)
sarima_results = sarima_model.fit(disp=False)

# Forecast
n_forecast = 30  # next 30 days
sarima_forecast = sarima_results.get_forecast(steps=n_forecast)
sarima_pred = sarima_forecast.predicted_mean

"""**MODEL 2:**

**LSTM (Long Short-Term Memory)**:

LSTM is a recurrent neural network (RNN) designed to learn long-term dependencies in sequential data.

It uses gates (input, forget, output) to control the flow of information across time steps.

Excellent for nonlinear and complex time series forecasting tasks.

Performs well on large datasets and captures both short- and long-term patterns effectively.
"""

# 4. Feature Engineering for LSTM
# --------------------------
lags = [1,7,14,30]
for lag in lags:
    df[f'lag_{lag}'] = df['Order_Demand'].shift(lag)
df['rolling_7'] = df['Order_Demand'].rolling(7).mean()
df.dropna(inplace=True)

# Scale for LSTM
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(df[['Order_Demand']])

# Sequence creation
def create_sequences(data, seq_length=30):
    X, y = [], []
    for i in range(seq_length, len(data)):
        X.append(data[i-seq_length:i,0])
        y.append(data[i,0])
    return np.array(X), np.array(y)

seq_length = 30
X_lstm, y_lstm = create_sequences(scaled_data, seq_length)
split = int(0.8 * len(X_lstm))
X_train, X_test = X_lstm[:split], X_lstm[split:]
y_train, y_test = y_lstm[:split], y_lstm[split:]

# Reshape for LSTM [samples, timesteps, features]
X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

# 5. LSTM Model
# --------------------------
lstm_model = Sequential()
lstm_model.add(LSTM(50, activation='relu', input_shape=(seq_length,1)))
lstm_model.add(Dense(1))
lstm_model.compile(optimizer='adam', loss='mse')

lstm_model.fit(X_train, y_train, epochs=20, batch_size=32, validation_split=0.1, verbose=1)

# Predict and inverse scale
y_pred_lstm = lstm_model.predict(X_test)
y_pred_lstm = scaler.inverse_transform(y_pred_lstm)
y_test_actual = scaler.inverse_transform(y_test.reshape(-1,1))

# --------------------------
# 6. Model Comparison
# --------------------------
# For SARIMA comparison, take last n_test points
sarima_pred_last = sarima_results.get_prediction(start=df.index[-len(y_test_actual)], end=df.index[-1])
sarima_pred_last = sarima_pred_last.predicted_mean.values

# RMSE calculation
rmse_lstm = np.sqrt(mean_squared_error(y_test_actual, y_pred_lstm))
rmse_sarima = np.sqrt(mean_squared_error(y_test_actual, sarima_pred_last))
print(f"LSTM RMSE: {rmse_lstm:.2f}")
print(f"SARIMA RMSE: {rmse_sarima:.2f}")

# Plot Comparison
plt.figure(figsize=(12,6))
plt.plot(y_test_actual, label='Actual')
plt.plot(y_pred_lstm, label='LSTM Predicted')
plt.plot(sarima_pred_last, label='SARIMA Predicted')
plt.title("Petrol Demand Forecast: LSTM vs SARIMA")
plt.xlabel("Time")
plt.ylabel("Order Demand")
plt.legend()
plt.show()

# 7. KPI Calculations
# --------------------------
inventory_test = df['Order_Demand'].iloc[-len(y_test_actual):].values
price_per_unit = df['Petrol_price'].iloc[0]

# Stockout & Overstock
safety_stock = 0.1 * y_test_actual.flatten()
stockout_rate_lstm = np.mean(y_test_actual.flatten() > inventory_test) * 100
overstock_rate_lstm = np.mean(inventory_test > y_test_actual.flatten() + safety_stock) * 100

# Revenue Growth
revenue_actual = y_test_actual.flatten() * price_per_unit
revenue_pred = y_pred_lstm.flatten() * price_per_unit
revenue_growth = ((revenue_pred.sum() - revenue_actual.sum()) / revenue_actual.sum()) * 100

# Inventory trend
inventory_trend = inventory_test.mean() - y_test_actual.mean()

print(f"Stockout Rate: {stockout_rate_lstm:.2f}%")
print(f"Overstock Rate: {overstock_rate_lstm:.2f}%")
print(f"Revenue Growth: {revenue_growth:.2f}%")
print(f"Inventory Trend (mean diff): {inventory_trend:.2f}")

# --------------------------
# 8. Cross Validation & Hyperparameter Tuning (Example for SARIMA)
# --------------------------
# Simple Grid Search Example (p,d,q) x (P,D,Q,s)
import itertools
import warnings
warnings.filterwarnings("ignore")

p = d = q = range(0,2)
pdq = list(itertools.product(p,d,q))
seasonal_pdq = [(x[0],x[1],x[2],7) for x in pdq]

best_aic = np.inf
best_params = None
for param in pdq:
    for param_seasonal in seasonal_pdq:
        try:
            mod = SARIMAX(df['order_demand'], order=param, seasonal_order=param_seasonal,
                          enforce_stationarity=False, enforce_invertibility=False)
            results = mod.fit(disp=False)
            if results.aic < best_aic:
                best_aic = results.aic
                best_params = (param, param_seasonal)
        except:
            continue
print("Best SARIMA params:", best_params, "with AIC:", best_aic)

# --------------------------
# 1. SARIMA/SARIMAX: Best for short-term stable forecasts, interpretable, easy to explain to clients.
# 2. LSTM: Best for capturing nonlinear trends and long-term dependencies.
# 3. KPI-based evaluation helps decide which model is better for client purpose (stockout, revenue, inventory optimization).

# Ensure 'Date' column is datetime
df['Date'] = pd.to_datetime(df['Date'])

# Get last date
last_date = df['Date'].max()

# Create future dates
n_future = 7
future_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=n_future)
print(future_dates)

# SARIMA prediction DataFrame
sarima_future_df = pd.DataFrame({
    'Date': future_dates,
    'Predicted_Order_Demand': sarima_future_pred
})
print("SARIMA 7-day Forecast:\n", sarima_future_df)

# Use last sequence from scaled_data for prediction
last_seq = scaled_data[-seq_length:]  # last 30 days
lstm_future_preds = []

current_seq = last_seq.copy()
for _ in range(n_future):
    pred = lstm_model.predict(current_seq.reshape(1, seq_length, 1))
    lstm_future_preds.append(pred[0,0])
    # update sequence
    current_seq = np.append(current_seq[1:], pred[0,0]).reshape(-1,1)

# Inverse scale
lstm_future_preds = scaler.inverse_transform(np.array(lstm_future_preds).reshape(-1,1)).flatten()

# LSTM prediction DataFrame
lstm_future_df = pd.DataFrame({
    'Date': future_dates,
    'Predicted_Order_Demand': lstm_future_preds
})
print("LSTM 7-day Forecast:\n", lstm_future_df)

#Combine Forecasts into One Table
# Assume these are your forecasts
# sarima_future_pred -> SARIMA predictions (array of 7 values)
# lstm_future_preds -> LSTM predictions (array of 7 values)
# future_dates -> corresponding 7 future dates

comparison_df = pd.DataFrame({
    'Date': future_dates,
    'SARIMA_Predicted_Demand': sarima_future_pred,
    'LSTM_Predicted_Demand': lstm_future_preds
})

print(comparison_df)

# Inventory and price assumptions
inventory_future = np.repeat(df['Order_Demand'].iloc[-7:].mean(), 7)
price_per_unit = df['Petrol_price'].iloc[0]

# Safety stock
safety_stock_sarima = 0.1 * sarima_future_pred
safety_stock_lstm = 0.1 * lstm_future_preds

# SARIMA KPIs
sarima_stockout_rate = np.mean(sarima_future_pred > inventory_future) * 100
sarima_overstock_rate = np.mean(inventory_future > sarima_future_pred + safety_stock_sarima) * 100
sarima_revenue = sarima_future_pred.sum() * price_per_unit

# LSTM KPIs
lstm_stockout_rate = np.mean(lstm_future_preds > inventory_future) * 100
lstm_overstock_rate = np.mean(inventory_future > lstm_future_preds + safety_stock_lstm) * 100
lstm_revenue = lstm_future_preds.sum() * price_per_unit

print("SARIMA: Stockout %.2f%%, Overstock %.2f%%, Revenue %.2f" % (sarima_stockout_rate, sarima_overstock_rate, sarima_revenue))
print("LSTM: Stockout %.2f%%, Overstock %.2f%%, Revenue %.2f" % (lstm_stockout_rate, lstm_overstock_rate, lstm_revenue))

import matplotlib.pyplot as plt

plt.figure(figsize=(10,5))
plt.plot(future_dates, sarima_future_pred, label='SARIMA Forecast', marker='o')
plt.plot(future_dates, lstm_future_preds, label='LSTM Forecast', marker='x')
plt.plot(future_dates, inventory_future, label='Inventory Level', linestyle='--')
plt.xlabel('Date')
plt.ylabel('Order Demand')
plt.title('Next 7 Days Forecast Comparison')
plt.legend()
plt.show()

"""Decide Which Model to Use

Choose SARIMA when:

Your demand is stable or seasonal.

You want easy-to-explain forecasts for inventory planning.

You prioritize lower overstock rather than revenue spikes.

Choose LSTM when:

Your demand is nonlinear or has sudden changes.

You want to capture spikes and trends.

You prioritize higher revenue and accurate peak demand prediction.

Rule of thumb:

Compare stockout rate and revenue:

Lower stockout + higher revenue â†’ best model.

If both are similar, SARIMA is more interpretable.
"""

